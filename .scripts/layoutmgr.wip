#!/bin/sh
#  Launches predefined commands in linear order, useful for restoring common
#  workflow layouts.

# Exit if no layout file argument is provided
[ -z "$1" ] && exit
LO="$1"
echo "Layout: $LO"

# initalizes or resets globals
reset_globals() {
    # the current unit's command
    CMD=""
    # the current unit's workspace
    WS=""
    # the current script state step
    STEP=0
}

# parses the layout file for execution
prep_layout() {
    # break layout into seperate lines, and remove <> delims
    PARAMS=$(sed "s/<//g; s/>\ /\n/g; s/\(.\)$//" "$1")
    # return params via stdout
    echo $PARAMS
}

# Executes a "Unit" (a single <command> <workspace> pair in a layout file)
run_unit() {
   # don't focus a desktop twice in a row
   [ ! "$LAST_WS" = "$WS" ] && focus-ws "$WS";

   # execute the command, and sleep for a moment (just to ensure linear order probably not needed though)
   sh -c "$CMD" & sleep 0.1

   # remember the used workspace
   LAST_WS="$WS"
}

# loop for each 2 seperate lines of the parsed layout,
# gathering the command and workspace, executing,
# and reset state for the next
driver_loop() {
    while read -r line; do
        # if step 0, load the line into CMD
        [ "$STEP" -eq 0 ] && CMD="${line}"
        # if step 1, load workspace into WS, and run the unit, then reset globals
        [ "$STEP" -eq 1 ] && WS="${line}" && run_unit ; CMD="" ; WS="" ; STEP=0

        # triggers step change to 1 on unit's second iteration
        [ ! "$CMD" = "" ] && STEP=1
    done <<EOF
        $PARAMS
EOF
}

# run script

# get return value of prep_layout
$PARAMS="$(prep_layout)"
# start the main execution loop
driver_loop
